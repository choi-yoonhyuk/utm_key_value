<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>UTM 옵션 마스터 목록 (파라미터 활성화 관리)</title>
<style>
    body { font-family: sans-serif; margin: 20px; font-size: 14px; }
    .button-container { margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; } 
    .button-container button { padding: 10px 15px; font-size: 1em; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 5px; }
    .button-container button:hover { background-color: #0056b3; }
    .button-container button#saveParameterStatusButton { background-color: #28a745; }
    .button-container button#saveParameterStatusButton:hover { background-color: #218838; }

    table { width: 100%; border-collapse: collapse; margin-top: 10px; table-layout: fixed; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: left; vertical-align: middle; word-wrap: break-word; }
    th { background-color: #f0f0f0; position: sticky; top: 0; z-index: 1; font-weight: bold; }

    td > span { margin-right: 8px; vertical-align: middle;}

    /* 토글 스위치 CSS */
    .toggle-switch {
        position: relative;
        display: inline-block;
        width: 40px; 
        height: 20px; 
        vertical-align: middle;
    }
    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc; 
        -webkit-transition: .4s;
        transition: .4s;
    }
    .slider:before {
        position: absolute;
        content: "";
        height: 16px; 
        width: 16px;  
        left: 2px;    
        bottom: 2px;  
        background-color: white;
        -webkit-transition: .4s;
        transition: .4s;
    }
    input:checked + .slider {
        background-color: #28a745; 
    }
    input:focus + .slider {
        box-shadow: 0 0 1px #28a745;
    }
    input:checked + .slider:before {
        -webkit-transform: translateX(20px); 
        -ms-transform: translateX(20px);
        transform: translateX(20px);
    }
    .slider.round {
        border-radius: 20px; 
    }
    .slider.round:before {
        border-radius: 50%; 
    }

    #loadingStatus { font-style: italic; color: #777; margin-bottom: 15px; }
    #tableContainerWrapper { max-height: 75vh; overflow-y: auto; border: 1px solid #ddd; }
    .status-message { margin-top: 10px; padding: 10px; border-radius: 4px; display: none; }
    .status-message.success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
    .status-message.error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
</style>
</head>
<body>
<div class="button-container">
    <button onclick="location.href='https://choi-yoonhyuk.github.io/source_medium_drop/'">UTM 빌더로 이동</button>
    <button id="saveParameterStatusButton">옵션 활성 상태 저장</button>
</div>
<h1>UTM 옵션 마스터 목록</h1>
<p id="loadingStatus">데이터 로딩 중...</p>
<div id="statusMessage" class="status-message"></div>

<div id="tableContainerWrapper">
    <div id="optionsTableContainer"></div>
</div>

<script>
    const MASTER_OPTIONS_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vShcppno7HuVQbjoQzbaBMEvoBGt6atss9FI_-F3qSh_pzgtxw7A4NPo6Y2EYoll2y5_8wMt08X_oV0/pub?gid=1861589139&single=true&output=csv';
    const N8N_WEBHOOK_URL_FOR_STATUS_UPDATE = 'https://entrench-consulting.app.n8n.cloud/webhook-test/15daaf64-30ee-4b32-9426-45a8c8bd9184';

    const elementStates = new Map(); // key: "columnName::optionValue", value: isChecked (boolean)
    const elementCheckboxes = new Map(); // key: "columnName::optionValue", value: Set<HTMLInputElement>

    document.addEventListener('DOMContentLoaded', async () => {
        const loadingStatusEl = document.getElementById('loadingStatus');
        const tableContainerEl = document.getElementById('optionsTableContainer');
        const saveButton = document.getElementById('saveParameterStatusButton');

        if (!MASTER_OPTIONS_CSV_URL || MASTER_OPTIONS_CSV_URL.startsWith('여기에_')) {
            loadingStatusEl.textContent = "오류: 구글 시트 CSV URL이 설정되지 않았습니다.";
            loadingStatusEl.style.color = "red";
            saveButton.disabled = true;
            return;
        }
        if (!N8N_WEBHOOK_URL_FOR_STATUS_UPDATE || N8N_WEBHOOK_URL_FOR_STATUS_UPDATE.startsWith('여기에_')) {
            console.warn("N8N 웹훅 URL이 설정되지 않았습니다. '저장' 기능이 정상 동작하지 않을 수 있습니다.");
        }
        
        saveButton.addEventListener('click', handleSaveParameterStatus);

        try {
            loadingStatusEl.textContent = "옵션 목록 로딩 중...";
            const response = await fetch(MASTER_OPTIONS_CSV_URL, { cache: 'no-cache' }); 
            if (!response.ok) throw new Error(`마스터 옵션 CSV 로드 실패 (상태 코드: ${response.status})`);
            const csvDataText = await response.text(); 
            if (!csvDataText.trim()) {
                loadingStatusEl.textContent = "옵션 데이터가 비어있거나 가져올 수 없습니다.";
                tableContainerEl.innerHTML = '<p>표시할 옵션 데이터가 없습니다.</p>';
                return;
            }
            
            // 'type' 컬럼을 숨기도록 headersToHide 배열에 전달
            const tableElement = createOrganizedTableFromCsv(csvDataText, ['type']); 
            
            tableContainerEl.innerHTML = ''; 
            tableContainerEl.appendChild(tableElement); 
            
            loadingStatusEl.style.display = 'none'; 

        } catch (error) {
            console.error("마스터 옵션 로딩 또는 표시 오류:", error);
            loadingStatusEl.textContent = `오류: ${error.message}`;
            loadingStatusEl.style.color = "red";
            tableContainerEl.innerHTML = '<p>옵션 목록을 불러오는 데 실패했습니다.</p>';
        }
    });

    function displayStatusMessage(message, isSuccess) {
        const statusMessageEl = document.getElementById('statusMessage');
        statusMessageEl.textContent = message;
        statusMessageEl.className = 'status-message ' + (isSuccess ? 'success' : 'error');
        statusMessageEl.style.display = 'block';
        setTimeout(() => { statusMessageEl.style.display = 'none'; }, 5000);
    }
    
    async function handleSaveParameterStatus() {
        const loadingStatusEl = document.getElementById('loadingStatus');
        const saveButton = document.getElementById('saveParameterStatusButton');
        saveButton.disabled = true;
        loadingStatusEl.textContent = "옵션 상태 저장 중...";
        loadingStatusEl.style.display = 'block';

        const statusPayload = {};
        elementStates.forEach((isChecked, uniqueKey) => { 
            const parts = uniqueKey.split('::');
            let payloadKeyPart = uniqueKey; 
            if (parts.length === 2) {
                payloadKeyPart = `${parts[0]}_${parts[1]}`; 
            }
            const sanitizedKeyPart = payloadKeyPart.replace(/[^a-zA-Z0-9_]+/g, '_').replace(/^_+|_+$/g, '');
            statusPayload[`${sanitizedKeyPart}_is_active`] = isChecked ? 'Y' : 'N';
        });

        console.log("Sending element statuses to n8n:", statusPayload);

        if (Object.keys(statusPayload).length === 0) {
            displayStatusMessage("저장할 옵션 상태가 없습니다.", false);
            loadingStatusEl.style.display = 'none';
            saveButton.disabled = false;
            return;
        }

        if (!N8N_WEBHOOK_URL_FOR_STATUS_UPDATE || N8N_WEBHOOK_URL_FOR_STATUS_UPDATE.startsWith('여기에_')) {
            displayStatusMessage("오류: N8N 웹훅 URL이 설정되지 않아 저장할 수 없습니다.", false);
            loadingStatusEl.style.display = 'none';
            saveButton.disabled = false;
            return;
        }

        try {
            const response = await fetch(N8N_WEBHOOK_URL_FOR_STATUS_UPDATE, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(statusPayload)
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`n8n 저장 요청 실패 (${response.status}): ${errorText || '알 수 없는 오류'}`);
            }
            await response.json(); 
            displayStatusMessage("옵션 활성 상태가 n8n으로 전송되었습니다.", true);

        } catch (error) {
            console.error("Error saving element status to n8n:", error);
            displayStatusMessage(`오류 발생: ${error.message}`, false);
        } finally {
            loadingStatusEl.style.display = 'none';
            saveButton.disabled = false;
        }
    }

    function createOrganizedTableFromCsv(csvDataText, headersToHide = []) {
        const lines = csvDataText.split(/\r?\n/).filter(line => line.trim() !== "");
        const table = document.createElement('table');

        if (lines.length === 0) {
            table.innerHTML = '<tr><td>표시할 데이터가 없습니다 (CSV 비어있음).</td></tr>';
            return table;
        }

        const allCsvHeaders = lines[0].split(',').map(header => header.trim().replace(/^"|"$/g, ''));
        const csvDataRows = lines.slice(2);
        
        const originalHeaderIndexMap = new Map(); 
        allCsvHeaders.forEach((header, index) => originalHeaderIndexMap.set(header, index));

        const lowerCaseHeadersToHide = headersToHide.map(h => h.toLowerCase());
        
        const displayHeaders = [];
        allCsvHeaders.forEach((headerName) => {
            const lowercasedHeader = headerName.toLowerCase();
            // --- START DEBUG LOG FOR COLUMN HIDING ---
            // 특정 헤더(예: 'type')가 숨김 처리되는지 확인하기 위한 로그
            if (lowerCaseHeadersToHide.includes(lowercasedHeader)) {
                console.log(`[CSV Header Check] Hiding Column: Original='${headerName}', Lowercased='${lowercasedHeader}', Matched in Hide list: ${JSON.stringify(lowerCaseHeadersToHide)}`);
            }
            // --- END DEBUG LOG ---

            if (headerName.endsWith('_is_active')) return; 
            if (lowerCaseHeadersToHide.includes(lowercasedHeader)) return; 
            displayHeaders.push(headerName);
        });
        
        console.log("[Debug] Display Headers:", JSON.stringify(displayHeaders)); // 실제로 표시될 헤더 목록 확인

        elementStates.clear();
        elementCheckboxes.clear();

        csvDataRows.forEach(dataLine => {
            const currentDataCells = dataLine.split(',').map(cell => cell.trim().replace(/^"|"$/g, ''));
            displayHeaders.forEach(valueColumnName => { 
                const valueColIndex = originalHeaderIndexMap.get(valueColumnName);
                const cellValue = (valueColIndex !== undefined && currentDataCells.length > valueColIndex) 
                                ? currentDataCells[valueColIndex] 
                                : "";

                if (cellValue && cellValue.toLowerCase() !== 'undefined') {
                    const uniqueKey = `${valueColumnName}::${cellValue}`;
                    let isActiveForRow = false; 

                    const statusColumnNameForThisValue = `${valueColumnName}_is_active`;
                    const statusColIndex = originalHeaderIndexMap.get(statusColumnNameForThisValue);

                    if (statusColIndex !== undefined && currentDataCells.length > statusColIndex) {
                        const statusValueFromCell = currentDataCells[statusColIndex].toUpperCase();
                        if (statusValueFromCell === 'Y') {
                            isActiveForRow = true;
                        }
                    }
                    
                    if (elementStates.has(uniqueKey)) {
                        if (isActiveForRow && !elementStates.get(uniqueKey)) { 
                            elementStates.set(uniqueKey, true);
                        }
                    } else { 
                        elementStates.set(uniqueKey, isActiveForRow);
                    }
                }
            });
        });
        
        const thead = table.createTHead();
        const headerRow = thead.insertRow();
        displayHeaders.forEach(headerText => {
            const th = document.createElement('th');
            th.textContent = headerText; 
            headerRow.appendChild(th);
        });
        
        const tbody = table.createTBody();
        if (csvDataRows.length === 0 && displayHeaders.length > 0) {
             const tr = tbody.insertRow();
             const td = tr.insertCell();
             td.colSpan = displayHeaders.length || 1;
             td.textContent = "표시할 데이터 행이 없습니다."; 
             td.style.textAlign = "center";
        } else if (displayHeaders.length === 0) {
            const tr = tbody.insertRow();
            const td = tr.insertCell();
            td.textContent = "표시할 컬럼이 없습니다.";
            return table;
        }

        csvDataRows.forEach(dataLine => {
            const tr = tbody.insertRow();
            const currentDataCells = dataLine.split(',').map(cell => cell.trim().replace(/^"|"$/g, ''));

            displayHeaders.forEach(headerText => { 
                const td = tr.insertCell();
                td.innerHTML = ''; 
                const originalColIndex = originalHeaderIndexMap.get(headerText);
                let cellValue = "";
                if (originalColIndex !== undefined && currentDataCells.length > originalColIndex) {
                     cellValue = String(currentDataCells[originalColIndex]).trim();
                }

                if (!cellValue || cellValue.toLowerCase() === 'undefined') {
                    // 빈 셀
                } else {
                    const textSpan = document.createElement('span');
                    textSpan.textContent = cellValue;
                    td.appendChild(textSpan);

                    const uniqueKey = `${headerText}::${cellValue}`; 

                    if (elementStates.has(uniqueKey)) { 
                        const toggleLabel = document.createElement('label');
                        toggleLabel.className = 'toggle-switch';

                        const hiddenCheckbox = document.createElement('input');
                        hiddenCheckbox.type = 'checkbox';
                        hiddenCheckbox.checked = elementStates.get(uniqueKey) || false;
                        
                        const sliderSpan = document.createElement('span');
                        sliderSpan.className = 'slider round';

                        toggleLabel.appendChild(hiddenCheckbox);
                        toggleLabel.appendChild(sliderSpan);
                        td.appendChild(toggleLabel);

                        if (!elementCheckboxes.has(uniqueKey)) {
                            elementCheckboxes.set(uniqueKey, new Set());
                        }
                        elementCheckboxes.get(uniqueKey).add(hiddenCheckbox);

                        hiddenCheckbox.addEventListener('change', () => {
                            const newState = hiddenCheckbox.checked;
                            elementStates.set(uniqueKey, newState); 

                            const checkboxesToSync = elementCheckboxes.get(uniqueKey);
                            if (checkboxesToSync) {
                                checkboxesToSync.forEach(cb => {
                                    if (cb !== hiddenCheckbox) { 
                                        cb.checked = newState;
                                    }
                                });
                            }
                        });
                    }
                }
            });
        });
        return table;
    }
</script>
</body>
</html>